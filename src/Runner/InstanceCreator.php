<?php

/*
 * PHPSure
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/phpsure/phpsure/
 *
 * Released under the MIT license.
 * https://github.com/phpsure/phpsure/raw/main/MIT-LICENSE.txt
 */

declare(strict_types=1);

namespace PHPSure\Runner;

use PHPSure\Attributes\FixtureInterface;
use PHPSure\Generator\ArgumentResolverInterface;
use PHPSure\Generator\FixtureMaterialiserInterface;
use PHPSure\Generator\TokenGenerator;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;
use ReflectionNamedType;
use Throwable;

/**
 * Class InstanceCreator.
 *
 * Creates instances of classes using scenarios or auto-generation.
 *
 * @author Dan Phillimore <dan@ovms.co>
 */
class InstanceCreator implements InstanceCreatorInterface
{
    public function __construct(
        private readonly ScenarioManagerInterface $scenarioManager,
        private readonly ArgumentResolverInterface $argumentResolver,
        private readonly FixtureMaterialiserInterface $fixtureMaterialiser,
        private readonly TokenGenerator $tokenGenerator
    ) {
    }

    /**
     * Creates an instance of a class using fixture/ctor rules.
     *
     * @param string $className The class name.
     * @param bool &$wasAutoGenerated Output parameter indicating if the instance was auto-generated.
     * @return object|null The instance, or null if it could not be created.
     * @throws ReflectionException When the class cannot be reflected.
     */
    public function createInstance(string $className, bool &$wasAutoGenerated = false): ?object
    {
        return $this->createInstanceForFixture($className, null, $wasAutoGenerated);
    }

    /**
     * Creates an instance of a class using a specific constructor fixture.
     *
     * @param string $className The class name.
     * @param string|null $fixtureName The name of the constructor fixture to use, or null for default behavior.
     * @param bool &$wasAutoGenerated Output parameter indicating if the instance was auto-generated.
     * @return object|null The instance, or null if it could not be created.
     * @throws ReflectionException When the class cannot be reflected.
     */
    public function createInstanceForFixture(string $className, ?string $fixtureName, bool &$wasAutoGenerated = false): ?object
    {
        $class = new ReflectionClass($className);
        $constructor = $class->getConstructor();

        // First, look for fixtures on static factory methods.
        $factoryFixtures = $this->findFactoryFixtures($class, $fixtureName, $wasAutoGenerated);

        if ($factoryFixtures !== null) {
            return $factoryFixtures;
        }

        // If no factory fixtures, look at the constructor.
        if ($constructor === null) {
            // No constructor, just instantiate.
            return new $className();
        }

        $constructorFixtures = $this->scenarioManager->getFixtures($constructor);

        // If a specific fixture is requested, use it.
        if ($fixtureName !== null) {
            $fixture = $this->scenarioManager->findFixtureByName($constructorFixtures, $fixtureName);
            if ($fixture !== null) {
                $args = $this->argumentResolver->resolveScenarioArguments(
                    $fixture->getArguments(),
                    $this->fixtureMaterialiser
                );

                return $class->newInstanceArgs($args);
            }

            // Fixture not found. For public constructors requesting 'default', fall through to auto-generation.
            // For private constructors or other fixtures, return null.
            if ($fixtureName !== FixtureInterface::DEFAULT_NAME || !$constructor->isPublic()) {
                return null;
            }

            // Fall through to auto-generate 'default' for public constructor.
        }

        // Look for a 'default' fixture on the constructor.
        $defaultFixture = $this->scenarioManager->findFixtureByName($constructorFixtures, FixtureInterface::DEFAULT_NAME);
        if ($defaultFixture !== null) {
            $args = $this->argumentResolver->resolveScenarioArguments(
                $defaultFixture->getArguments(),
                $this->fixtureMaterialiser
            );

            return $class->newInstanceArgs($args);
        }

        // Look for the first constructor fixture.
        if (!empty($constructorFixtures)) {
            $fixture = reset($constructorFixtures);
            $args = $this->argumentResolver->resolveScenarioArguments(
                $fixture->getArguments(),
                $this->fixtureMaterialiser
            );

            return $class->newInstanceArgs($args);
        }

        // No constructor fixture - try to generate one automatically using token generator.
        if ($constructor->isPublic()) {
            try {
                $args = $this->tokenGenerator->generateForParameters($constructor);
                $wasAutoGenerated = true;

                return $class->newInstanceArgs($args);
            } catch (Throwable) {
                // Could not auto-generate - return null.
                return null;
            }
        }

        // Constructor is not public and no fixtures available - cannot create instance.
        return null;
    }

    /**
     * Finds a factory fixture for creating an instance.
     *
     * @param ReflectionClass<object> $class The class to search.
     * @param string|null $fixtureName The name of the fixture to find, or null for default.
     * @param bool &$wasAutoGenerated Output parameter indicating if the instance was auto-generated.
     * @return object|null The created instance, or null if no suitable factory fixture was found.
     * @throws ReflectionException When a method cannot be reflected.
     */
    private function findFactoryFixtures(ReflectionClass $class, ?string $fixtureName, bool &$wasAutoGenerated = false): ?object
    {
        // First, look for fixtures on the constructor.
        $constructor = $class->getConstructor();
        if ($constructor !== null) {
            $constructorFixtures = $this->scenarioManager->getFixtures($constructor);

            if (!empty($constructorFixtures)) {
                // If a specific fixture is requested, look for it.
                if ($fixtureName !== null) {
                    $fixture = $this->scenarioManager->findFixtureByName($constructorFixtures, $fixtureName);

                    if ($fixture !== null) {
                        $args = $this->argumentResolver->resolveScenarioArguments(
                            $fixture->getArguments(),
                            $this->fixtureMaterialiser
                        );

                        return $class->newInstanceArgs($args);
                    }
                    // If specific fixture not found on constructor, continue to static factory methods.
                } else {
                    // Look for a 'default' fixture.
                    $defaultFixture = $this->scenarioManager->findFixtureByName($constructorFixtures, FixtureInterface::DEFAULT_NAME);

                    if ($defaultFixture !== null) {
                        $args = $this->argumentResolver->resolveScenarioArguments(
                            $defaultFixture->getArguments(),
                            $this->fixtureMaterialiser
                        );

                        return $class->newInstanceArgs($args);
                    }
                }
            }
        }

        // If no constructor fixtures or specific fixture not found, look for static factory methods with fixtures.
        foreach ($class->getMethods(ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_STATIC) as $method) {
            // Skip non-static methods (constructor can be returned by getMethods with IS_STATIC flag).
            if (!$method->isStatic()) {
                continue;
            }

            $fixtures = $this->scenarioManager->getFixtures($method);

            if (empty($fixtures)) {
                continue;
            }

            // If a specific fixture is requested, look for it.
            if ($fixtureName !== null) {
                $fixture = $this->scenarioManager->findFixtureByName($fixtures, $fixtureName);

                if ($fixture !== null) {
                    $args = $this->argumentResolver->resolveScenarioArguments(
                        $fixture->getArguments(),
                        $this->fixtureMaterialiser
                    );

                    return $method->invoke(null, ...$args);
                }
            } else {
                // Look for a 'default' fixture.
                $defaultFixture = $this->scenarioManager->findFixtureByName($fixtures, FixtureInterface::DEFAULT_NAME);

                if ($defaultFixture !== null) {
                    $args = $this->argumentResolver->resolveScenarioArguments(
                        $defaultFixture->getArguments(),
                        $this->fixtureMaterialiser
                    );

                    return $method->invoke(null, ...$args);
                }
            }
        }

        // If no default fixture found and we're looking for default, try to auto-generate one.
        if ($fixtureName === null) {
            // Check if constructor is private.
            $constructor = $class->getConstructor();
            $hasPrivateConstructor = $constructor !== null && !$constructor->isPublic();

            // If constructor is private, do NOT use the first available fixture or auto-generate.
            // This would be too magic and confusing. Return null to trigger a warning.
            if ($hasPrivateConstructor) {
                return null;
            }

            // Only for public constructors: try to use the first static factory method with fixtures.
            foreach ($class->getMethods(ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_STATIC) as $method) {
                // Skip non-static methods (constructor can be returned by getMethods with IS_STATIC flag).
                if (!$method->isStatic()) {
                    continue;
                }

                $fixtures = $this->scenarioManager->getFixtures($method);

                if (!empty($fixtures)) {
                    // Use the first available fixture.
                    $firstFixture = reset($fixtures);
                    if ($firstFixture !== false) {
                        $args = $this->argumentResolver->resolveScenarioArguments(
                            $firstFixture->getArguments(),
                            $this->fixtureMaterialiser
                        );

                        return $method->invoke(null, ...$args);
                    }
                }
            }

            // Try to auto-generate using the first static factory method that returns the class type.
            foreach ($class->getMethods(ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_STATIC) as $method) {
                // Skip non-static methods (constructor can be returned by getMethods with IS_STATIC flag).
                if (!$method->isStatic()) {
                    continue;
                }

                $returnType = $method->getReturnType();
                if ($returnType instanceof ReflectionNamedType) {
                    $returnTypeName = $returnType->getName();
                    // Handle self, static, and parent return types.
                    $isMatchingReturnType = $returnTypeName === $class->getName() ||
                        in_array($returnTypeName, ['self', 'static'], true);

                    if ($isMatchingReturnType) {
                        try {
                            $args = $this->tokenGenerator->generateForParameters($method);
                            $wasAutoGenerated = true;
                            return $method->invoke(null, ...$args);
                        } catch (Throwable) {
                            // Could not auto-generate with this method, try next.
                            continue;
                        }
                    }
                }
            }
        }

        return null;
    }
}
