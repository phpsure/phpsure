<?php

/*
 * PHPSure
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/phpsure/phpsure/
 *
 * Released under the MIT license.
 * https://github.com/phpsure/phpsure/raw/main/MIT-LICENSE.txt
 */

declare(strict_types=1);

namespace PHPSure\Runner;

use PHPSure\Assert\TypeAsserter;
use PHPSure\Exception\ReturnTypeMismatchException;
use PHPSure\Exception\TypeMismatchException;
use PHPSure\Generator\ArgumentResolverInterface;
use PHPSure\Generator\FixtureMaterialiserInterface;
use PHPSure\Runner\Result\FailResult;
use PHPSure\Runner\Result\PassResult;
use PHPSure\Runner\Result\SkipResult;
use PHPSure\Runner\Result\WarningResult;
use ReflectionClass;
use ReflectionMethod;
use RuntimeException;
use Throwable;

/**
 * Class MethodTester.
 *
 * Tests individual methods.
 *
 * @author Dan Phillimore <dan@ovms.co>
 */
class MethodTester implements MethodTesterInterface
{
    public function __construct(
        private readonly TypeAsserter $typeAsserter,
        private readonly InstanceCreatorInterface $instanceCreator,
        private readonly ScenarioManagerInterface $scenarioManager,
        private readonly ExpectAsserterInterface $expectAsserter,
        private readonly ArgumentResolverInterface $argumentResolver,
        private readonly FixtureMaterialiserInterface $fixtureMaterialiser
    ) {
    }

    /**
     * Tests an instance method with optional scenario-based expect checks.
     *
     * @param string $className The class name.
     * @param string $methodName The method name.
     * @param ReflectionMethod $method The method reflection.
     * @param callable $invoker Callable that invokes the method and returns the result.
     * @param object|null $instance The instance to use for instance methods.
     * @param bool $instanceWasAutoGenerated Whether the instance was auto-generated.
     * @param array<PassResult> &$passes Output parameter for pass results.
     * @param array<FailResult> &$failures Output parameter for fail results.
     * @param array<SkipResult> &$skips Output parameter for skip results.
     * @param array<WarningResult> &$warnings Output parameter for warning results.
     */
    public function testInstanceMethod(
        string $className,
        string $methodName,
        ReflectionMethod $method,
        callable $invoker,
        ?object $instance,
        bool $instanceWasAutoGenerated,
        array &$passes,
        array &$failures,
        array &$skips,
        array &$warnings
    ): void {
        $scenarios = $this->scenarioManager->getScenarios($method);

        // If no scenarios, just do a basic type check with generated args.
        if (empty($scenarios)) {
            // For instance methods without scenarios, check if we have an instance.
            if ($instance === null) {
                // Check if this is due to a private constructor.
                $class = new ReflectionClass($className);
                $constructor = $class->getConstructor();
                $hasPrivateConstructor = $constructor !== null && !$constructor->isPublic();

                if ($hasPrivateConstructor) {
                    // Private constructor with no scenarios - this is a warning.
                    $warnings[] = new WarningResult(
                        $className . '->' . $methodName . '()',
                        'Cannot create instance for testing - private constructor requires explicit factory scenario'
                    );
                } else {
                    // Public constructor but couldn't create instance - this is a failure.
                    $failures[] = new FailResult(
                        $className . '->' . $methodName . '()',
                        'Cannot create instance for testing - no default constructor scenario available'
                    );
                }
                return;
            }

            try {
                $result = $invoker();
                try {
                    $this->typeAsserter->assertMatches($result, $method->getReturnType());
                } catch (TypeMismatchException $e) {
                    throw new ReturnTypeMismatchException($className . '->' . $methodName, $e);
                }

                $passes[] = new PassResult($className . '->' . $methodName . '()');
            } catch (ReturnTypeMismatchException $e) {
                $failures[] = new FailResult($className . '->' . $methodName . '()', $e->getMessage());
            } catch (Throwable $e) {
                $skips[] = new SkipResult($className . '->' . $methodName . '()', $e->getMessage());
            }
            return;
        }

        // Test each scenario.
        foreach ($scenarios as $scenario) {
            // Fixture attributes are not valid on instance methods, only Scenario attributes.
            if (!$scenario instanceof \PHPSure\Attributes\ScenarioInterface) {
                continue;
            }

            $scenarioDescription = $scenario->getDescription();
            $callableLabel = $className . '->' . $methodName . '()' . ($scenarioDescription !== null ? ' [' . $scenarioDescription . ']' : '');

            try {
                $args = $this->argumentResolver->resolveScenarioArguments($scenario->getArguments(), $this->fixtureMaterialiser);

                // For instance methods with scenarios, create instance using the specified instance fixture.
                $instanceAutoGenerated = false;

                $instanceToUse = $this->instanceCreator->createInstanceForFixture($className, $scenario->getInstanceFixtureName(), $instanceAutoGenerated);
                if ($instanceToUse === null) {
                    throw new RuntimeException(
                        sprintf(
                            'Cannot create instance for testing - no constructor fixture "%s" available',
                            $scenario->getInstanceFixtureName()
                        )
                    );
                }

                $result = $method->invoke($instanceToUse, ...$args);

                // First, check type.
                try {
                    $this->typeAsserter->assertMatches($result, $method->getReturnType());
                } catch (TypeMismatchException $e) {
                    throw new ReturnTypeMismatchException($callableLabel, $e);
                }

                // Then, check expect value if not 'type check'.
                if ($scenario->getExpectation() !== 'type check') {
                    $this->expectAsserter->assertExpect($result, $scenario->getExpectation(), $callableLabel);
                }

                $passes[] = new PassResult($callableLabel);
            } catch (ReturnTypeMismatchException $e) {
                $failures[] = new FailResult($callableLabel, $e->getMessage());
            } catch (RuntimeException $e) {
                $failures[] = new FailResult($callableLabel, $e->getMessage());
            } catch (Throwable $e) {
                $skips[] = new SkipResult($callableLabel, $e->getMessage());
            }
        }
    }

    /**
     * Tests a static method with optional scenario-based expect checks.
     *
     * @param string $className The class name.
     * @param string $methodName The method name.
     * @param ReflectionMethod $method The method reflection.
     * @param callable $invoker Callable that invokes the method and returns the result.
     * @param array<PassResult> &$passes Output parameter for pass results.
     * @param array<FailResult> &$failures Output parameter for fail results.
     * @param array<SkipResult> &$skips Output parameter for skip results.
     * @param array<WarningResult> &$warnings Output parameter for warning results.
     */
    public function testStaticMethod(
        string $className,
        string $methodName,
        ReflectionMethod $method,
        callable $invoker,
        array &$passes,
        array &$failures,
        array &$skips,
        array &$warnings
    ): void {
        $scenarios = $this->scenarioManager->getScenarios($method);

        // If no scenarios, just do a basic type check with generated args.
        if (empty($scenarios)) {
            try {
                $result = $invoker();
                try {
                    $this->typeAsserter->assertMatches($result, $method->getReturnType());
                } catch (TypeMismatchException $e) {
                    throw new ReturnTypeMismatchException($className . '::' . $methodName, $e);
                }

                $passes[] = new PassResult($className . '::' . $methodName . '()');
            } catch (ReturnTypeMismatchException $e) {
                $failures[] = new FailResult($className . '::' . $methodName . '()', $e->getMessage());
            } catch (Throwable $e) {
                $skips[] = new SkipResult($className . '::' . $methodName . '()', $e->getMessage());
            }
            return;
        }

        // Test each scenario.
        foreach ($scenarios as $scenario) {
            $scenarioDescription = $scenario->getDescription();

            // For Fixture attributes, use the fixture name if no description is provided.
            if ($scenarioDescription === null && $scenario instanceof \PHPSure\Attributes\FixtureInterface) {
                $scenarioDescription = $scenario->getName();
            }

            $callableLabel = $className . '::' . $methodName . '()' . ($scenarioDescription !== null ? ' [' . $scenarioDescription . ']' : '');

            try {
                $args = $this->argumentResolver->resolveScenarioArguments($scenario->getArguments(), $this->fixtureMaterialiser);
                $result = $method->invoke(null, ...$args);

                // First, check type.
                try {
                    $this->typeAsserter->assertMatches($result, $method->getReturnType());
                } catch (TypeMismatchException $e) {
                    throw new ReturnTypeMismatchException($callableLabel, $e);
                }

                // Then, check expect value if not 'type check'.
                if ($scenario->getExpectation() !== 'type check') {
                    $this->expectAsserter->assertExpect($result, $scenario->getExpectation(), $callableLabel);
                }

                $passes[] = new PassResult($callableLabel);
            } catch (ReturnTypeMismatchException $e) {
                $failures[] = new FailResult($callableLabel, $e->getMessage());
            } catch (RuntimeException $e) {
                $failures[] = new FailResult($callableLabel, $e->getMessage());
            } catch (Throwable $e) {
                $skips[] = new SkipResult($callableLabel, $e->getMessage());
            }
        }
    }
}
